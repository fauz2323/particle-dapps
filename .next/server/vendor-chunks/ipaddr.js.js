/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ipaddr.js";
exports.ids = ["vendor-chunks/ipaddr.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/ipaddr.js/lib/ipaddr.js":
/*!**********************************************!*\
  !*** ./node_modules/ipaddr.js/lib/ipaddr.js ***!
  \**********************************************/
/***/ (function(module) {

eval("(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if ( true && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaXBhZGRyLmpzL2xpYi9pcGFkZHIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxLQUFLLFNBQVMsS0FBSyxTQUFTLEtBQUssU0FBUztBQUNyRixtQ0FBbUMsU0FBUyxLQUFLLFNBQVMsS0FBSyxTQUFTO0FBQ3hFLGlDQUFpQyxTQUFTLEtBQUssU0FBUztBQUN4RCxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEdBQUc7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVMsc0JBQXNCLFVBQVU7QUFDaEYsc0RBQXNELFNBQVMsS0FBSyxTQUFTLEtBQUssU0FBUyxLQUFLLFNBQVMsR0FBRyxVQUFVO0FBQ3RILHlDQUF5QyxTQUFTLGFBQWEsU0FBUyxLQUFLLFNBQVMsS0FBSyxTQUFTLEtBQUssU0FBUyxLQUFLLFNBQVMsR0FBRyxVQUFVO0FBQzdJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUF1RixFQUFFO0FBQ3pGO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSw2QkFBNkIsWUFBWTtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0NBQW9DLElBQUksbURBQW1EO0FBQ2pIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLG1GQUFtRixFQUFFO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1YsbUZBQW1GLEVBQUU7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLEtBQTZCO0FBQ3JDOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXJ0aWNsZS1jb25uZWN0a2l0LWFwcC8uL25vZGVfbW9kdWxlcy9pcGFkZHIuanMvbGliL2lwYWRkci5qcz8yNzZiIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAocm9vdCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBBIGxpc3Qgb2YgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGFyYml0cmFyeSBJUHY0IGFkZHJlc3NlcyxcbiAgICAvLyBmb3Igd2hpY2ggYSBudW1iZXIgb2Ygd2VpcmQgbm90YXRpb25zIGV4aXN0LlxuICAgIC8vIE5vdGUgdGhhdCBhbiBhZGRyZXNzIGxpa2UgMDAxMC4weGE1LjEuMSBpcyBjb25zaWRlcmVkIGxlZ2FsLlxuICAgIGNvbnN0IGlwdjRQYXJ0ID0gJygwP1xcXFxkK3wweFthLWYwLTldKyknO1xuICAgIGNvbnN0IGlwdjRSZWdleGVzID0ge1xuICAgICAgICBmb3VyT2N0ZXQ6IG5ldyBSZWdFeHAoYF4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fSRgLCAnaScpLFxuICAgICAgICB0aHJlZU9jdGV0OiBuZXcgUmVnRXhwKGBeJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fSRgLCAnaScpLFxuICAgICAgICB0d29PY3RldDogbmV3IFJlZ0V4cChgXiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fSRgLCAnaScpLFxuICAgICAgICBsb25nVmFsdWU6IG5ldyBSZWdFeHAoYF4ke2lwdjRQYXJ0fSRgLCAnaScpXG4gICAgfTtcblxuICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbiBmb3IgY2hlY2tpbmcgT2N0YWwgbnVtYmVyc1xuICAgIGNvbnN0IG9jdGFsUmVnZXggPSBuZXcgUmVnRXhwKGBeMFswLTddKyRgLCAnaScpO1xuICAgIGNvbnN0IGhleFJlZ2V4ID0gbmV3IFJlZ0V4cChgXjB4W2EtZjAtOV0rJGAsICdpJyk7XG5cbiAgICBjb25zdCB6b25lSW5kZXggPSAnJVswLTlhLXpdezEsfSc7XG5cbiAgICAvLyBJUHY2LW1hdGNoaW5nIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgLy8gRm9yIElQdjYsIHRoZSB0YXNrIGlzIHNpbXBsZXI6IGl0IGlzIGVub3VnaCB0byBtYXRjaCB0aGUgY29sb24tZGVsaW1pdGVkXG4gICAgLy8gaGV4YWRlY2ltYWwgSVB2NiBhbmQgYSB0cmFuc2l0aW9uYWwgdmFyaWFudCB3aXRoIGRvdHRlZC1kZWNpbWFsIElQdjQgYXRcbiAgICAvLyB0aGUgZW5kLlxuICAgIGNvbnN0IGlwdjZQYXJ0ID0gJyg/OlswLTlhLWZdKzo6PykrJztcbiAgICBjb25zdCBpcHY2UmVnZXhlcyA9IHtcbiAgICAgICAgem9uZUluZGV4OiBuZXcgUmVnRXhwKHpvbmVJbmRleCwgJ2knKSxcbiAgICAgICAgJ25hdGl2ZSc6IG5ldyBSZWdFeHAoYF4oOjopPygke2lwdjZQYXJ0fSk/KFswLTlhLWZdKyk/KDo6KT8oJHt6b25lSW5kZXh9KT8kYCwgJ2knKSxcbiAgICAgICAgZGVwcmVjYXRlZFRyYW5zaXRpb25hbDogbmV3IFJlZ0V4cChgXig/Ojo6KSgke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fSgke3pvbmVJbmRleH0pPykkYCwgJ2knKSxcbiAgICAgICAgdHJhbnNpdGlvbmFsOiBuZXcgUmVnRXhwKGBeKCg/OiR7aXB2NlBhcnR9KXwoPzo6OikoPzoke2lwdjZQYXJ0fSk/KSR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9KCR7em9uZUluZGV4fSk/JGAsICdpJylcbiAgICB9O1xuXG4gICAgLy8gRXhwYW5kIDo6IGluIGFuIElQdjYgYWRkcmVzcyBvciBhZGRyZXNzIHBhcnQgY29uc2lzdGluZyBvZiBgcGFydHNgIGdyb3Vwcy5cbiAgICBmdW5jdGlvbiBleHBhbmRJUHY2IChzdHJpbmcsIHBhcnRzKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBvbmUgJzo6JyBtZWFucyBpbnZhbGlkIGFkZGRyZXNzXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignOjonKSAhPT0gc3RyaW5nLmxhc3RJbmRleE9mKCc6OicpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2xvbkNvdW50ID0gMDtcbiAgICAgICAgbGV0IGxhc3RDb2xvbiA9IC0xO1xuICAgICAgICBsZXQgem9uZUlkID0gKHN0cmluZy5tYXRjaChpcHY2UmVnZXhlcy56b25lSW5kZXgpIHx8IFtdKVswXTtcbiAgICAgICAgbGV0IHJlcGxhY2VtZW50LCByZXBsYWNlbWVudENvdW50O1xuXG4gICAgICAgIC8vIFJlbW92ZSB6b25lIGluZGV4IGFuZCBzYXZlIGl0IGZvciBsYXRlclxuICAgICAgICBpZiAoem9uZUlkKSB7XG4gICAgICAgICAgICB6b25lSWQgPSB6b25lSWQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLyUuKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIb3cgbWFueSBwYXJ0cyBkbyB3ZSBhbHJlYWR5IGhhdmU/XG4gICAgICAgIHdoaWxlICgobGFzdENvbG9uID0gc3RyaW5nLmluZGV4T2YoJzonLCBsYXN0Q29sb24gKyAxKSkgPj0gMCkge1xuICAgICAgICAgICAgY29sb25Db3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMDo6MCBpcyB0d28gcGFydHMgbW9yZSB0aGFuIDo6XG4gICAgICAgIGlmIChzdHJpbmcuc3Vic3RyKDAsIDIpID09PSAnOjonKSB7XG4gICAgICAgICAgICBjb2xvbkNvdW50LS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaW5nLnN1YnN0cigtMiwgMikgPT09ICc6OicpIHtcbiAgICAgICAgICAgIGNvbG9uQ291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9vcCB3b3VsZCBoYW5nIGlmIGNvbG9uQ291bnQgPiBwYXJ0c1xuICAgICAgICBpZiAoY29sb25Db3VudCA+IHBhcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2VtZW50ID0gJzonICsgJzA6JyAqIChwYXJ0cyAtIGNvbG9uQ291bnQpXG4gICAgICAgIHJlcGxhY2VtZW50Q291bnQgPSBwYXJ0cyAtIGNvbG9uQ291bnQ7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gJzonO1xuICAgICAgICB3aGlsZSAocmVwbGFjZW1lbnRDb3VudC0tKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCArPSAnMDonO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBtaXNzaW5nIHplcm9lc1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgnOjonLCByZXBsYWNlbWVudCk7XG5cbiAgICAgICAgLy8gVHJpbSBhbnkgZ2FyYmFnZSB3aGljaCBtYXkgYmUgaGFuZ2luZyBhcm91bmQgaWYgOjogd2FzIGF0IHRoZSBlZGdlIGluXG4gICAgICAgIC8vIHRoZSBzb3VyY2Ugc3RyaW5cbiAgICAgICAgaWYgKHN0cmluZ1swXSA9PT0gJzonKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaW5nW3N0cmluZy5sZW5ndGggLSAxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gc3RyaW5nLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50KHJlZltpXSwgMTYpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0cyxcbiAgICAgICAgICAgIHpvbmVJZDogem9uZUlkXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQSBnZW5lcmljIENJRFIgKENsYXNzbGVzcyBJbnRlci1Eb21haW4gUm91dGluZykgUkZDMTUxOCByYW5nZSBtYXRjaGVyLlxuICAgIGZ1bmN0aW9uIG1hdGNoQ0lEUiAoZmlyc3QsIHNlY29uZCwgcGFydFNpemUsIGNpZHJCaXRzKSB7XG4gICAgICAgIGlmIChmaXJzdC5sZW5ndGggIT09IHNlY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBjYW5ub3QgbWF0Y2ggQ0lEUiBmb3Igb2JqZWN0cyB3aXRoIGRpZmZlcmVudCBsZW5ndGhzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFydCA9IDA7XG4gICAgICAgIGxldCBzaGlmdDtcblxuICAgICAgICB3aGlsZSAoY2lkckJpdHMgPiAwKSB7XG4gICAgICAgICAgICBzaGlmdCA9IHBhcnRTaXplIC0gY2lkckJpdHM7XG4gICAgICAgICAgICBpZiAoc2hpZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RbcGFydF0gPj4gc2hpZnQgIT09IHNlY29uZFtwYXJ0XSA+PiBzaGlmdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2lkckJpdHMgLT0gcGFydFNpemU7XG4gICAgICAgICAgICBwYXJ0ICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludEF1dG8gKHN0cmluZykge1xuICAgICAgICAvLyBIZXhhZGVkaW1hbCBiYXNlIDE2ICgweCMpXG4gICAgICAgIGlmIChoZXhSZWdleC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGlsZSBvY3RhbCByZXByZXNlbnRhdGlvbiBpcyBkaXNjb3VyYWdlZCBieSBFQ01BU2NyaXB0IDNcbiAgICAgICAgLy8gYW5kIGZvcmJpZGRlbiBieSBFQ01BU2NyaXB0IDUsIHdlIHNpbGVudGx5IGFsbG93IGl0IHRvXG4gICAgICAgIC8vIHdvcmsgb25seSBpZiB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIGhhcyBudW1iZXJzIGxlc3MgdGhhbiA4LlxuICAgICAgICBpZiAoc3RyaW5nWzBdID09PSAnMCcgJiYgIWlzTmFOKHBhcnNlSW50KHN0cmluZ1sxXSwgMTApKSkge1xuICAgICAgICBpZiAob2N0YWxSZWdleC50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDgpO1xuICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlwYWRkcjogY2Fubm90IHBhcnNlICR7c3RyaW5nfSBhcyBvY3RhbGApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyBpbmNsdWRlIHRoZSBiYXNlIDEwIHJhZGl4IVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkUGFydCAocGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChwYXJ0Lmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcGFydCA9IGAwJHtwYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydDtcbiAgICB9XG5cbiAgICBjb25zdCBpcGFkZHIgPSB7fTtcblxuICAgIC8vIEFuIElQdjQgYWRkcmVzcyAoUkZDNzkxKS5cbiAgICBpcGFkZHIuSVB2NCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdHMgYSBuZXcgSVB2NCBhZGRyZXNzIGZyb20gYW4gYXJyYXkgb2YgZm91ciBvY3RldHNcbiAgICAgICAgLy8gaW4gbmV0d29yayBvcmRlciAoTVNCIGZpcnN0KVxuICAgICAgICAvLyBWZXJpZmllcyB0aGUgaW5wdXQuXG4gICAgICAgIGZ1bmN0aW9uIElQdjQgKG9jdGV0cykge1xuICAgICAgICAgICAgaWYgKG9jdGV0cy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaXB2NCBvY3RldCBjb3VudCBzaG91bGQgYmUgNCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaSwgb2N0ZXQ7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvY3RldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvY3RldCA9IG9jdGV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaXB2NCBvY3RldCBzaG91bGQgZml0IGluIDggYml0cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vY3RldHMgPSBvY3RldHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIElQdjQgYWRkcmVzcyByYW5nZXMuXG4gICAgICAgIC8vIFNlZSBhbHNvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jlc2VydmVkX0lQX2FkZHJlc3Nlc1xuICAgICAgICBJUHY0LnByb3RvdHlwZS5TcGVjaWFsUmFuZ2VzID0ge1xuICAgICAgICAgICAgdW5zcGVjaWZpZWQ6IFtbbmV3IElQdjQoWzAsIDAsIDAsIDBdKSwgOF1dLFxuICAgICAgICAgICAgYnJvYWRjYXN0OiBbW25ldyBJUHY0KFsyNTUsIDI1NSwgMjU1LCAyNTVdKSwgMzJdXSxcbiAgICAgICAgICAgIC8vIFJGQzMxNzFcbiAgICAgICAgICAgIG11bHRpY2FzdDogW1tuZXcgSVB2NChbMjI0LCAwLCAwLCAwXSksIDRdXSxcbiAgICAgICAgICAgIC8vIFJGQzM5MjdcbiAgICAgICAgICAgIGxpbmtMb2NhbDogW1tuZXcgSVB2NChbMTY5LCAyNTQsIDAsIDBdKSwgMTZdXSxcbiAgICAgICAgICAgIC8vIFJGQzU3MzVcbiAgICAgICAgICAgIGxvb3BiYWNrOiBbW25ldyBJUHY0KFsxMjcsIDAsIDAsIDBdKSwgOF1dLFxuICAgICAgICAgICAgLy8gUkZDNjU5OFxuICAgICAgICAgICAgY2FycmllckdyYWRlTmF0OiBbW25ldyBJUHY0KFsxMDAsIDY0LCAwLCAwXSksIDEwXV0sXG4gICAgICAgICAgICAvLyBSRkMxOTE4XG4gICAgICAgICAgICAncHJpdmF0ZSc6IFtcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzEwLCAwLCAwLCAwXSksIDhdLFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTcyLCAxNiwgMCwgMF0pLCAxMl0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTIsIDE2OCwgMCwgMF0pLCAxNl1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBhbmQgdGVzdGluZy1vbmx5IHJhbmdlczsgUkZDcyA1NzM1LCA1NzM3LCAyNTQ0LCAxNzAwXG4gICAgICAgICAgICByZXNlcnZlZDogW1xuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTkyLCAwLCAwLCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5MiwgMCwgMiwgMF0pLCAyNF0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTIsIDg4LCA5OSwgMF0pLCAyNF0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTgsIDE4LCAwLCAwXSksIDE1XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5OCwgNTEsIDEwMCwgMF0pLCAyNF0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsyMDMsIDAsIDExMywgMF0pLCAyNF0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsyNDAsIDAsIDAsIDBdKSwgNF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBSRkM3NTM0LCBSRkM3NTM1XG4gICAgICAgICAgICBhczExMjogW1xuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTkyLCAxNzUsIDQ4LCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5MiwgMzEsIDE5NiwgMF0pLCAyNF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgLy8gUkZDNzQ1MFxuICAgICAgICAgICAgYW10OiBbXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTIsIDUyLCAxOTMsIDBdKSwgMjRdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUaGUgJ2tpbmQnIG1ldGhvZCBleGlzdHMgb24gYm90aCBJUHY0IGFuZCBJUHY2IGNsYXNzZXMuXG4gICAgICAgIElQdjQucHJvdG90eXBlLmtpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lwdjQnO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGlzIGFkZHJlc3MgbWF0Y2hlcyBvdGhlciBvbmUgd2l0aGluIGdpdmVuIENJRFIgcmFuZ2UuXG4gICAgICAgIElQdjQucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKG90aGVyLCBjaWRyUmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCByZWY7XG4gICAgICAgICAgICBpZiAoY2lkclJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBvdGhlcjtcbiAgICAgICAgICAgICAgICBvdGhlciA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICBjaWRyUmFuZ2UgPSByZWZbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBjYW5ub3QgbWF0Y2ggaXB2NCBhZGRyZXNzIHdpdGggbm9uLWlwdjQgb25lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5vY3RldHMsIG90aGVyLm9jdGV0cywgOCwgY2lkclJhbmdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGEgbnVtYmVyIG9mIGxlYWRpbmcgb25lcyBpbiBJUHY0IGFkZHJlc3MsIG1ha2luZyBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIHJlc3QgaXMgYSBzb2xpZCBzZXF1ZW5jZSBvZiAwJ3MgKHZhbGlkIG5ldG1hc2spXG4gICAgICAgIC8vIHJldHVybnMgZWl0aGVyIHRoZSBDSURSIGxlbmd0aCBvciBudWxsIGlmIG1hc2sgaXMgbm90IHZhbGlkXG4gICAgICAgIElQdjQucHJvdG90eXBlLnByZWZpeExlbmd0aEZyb21TdWJuZXRNYXNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IGNpZHIgPSAwO1xuICAgICAgICAgICAgLy8gbm9uLXplcm8gZW5jb3VudGVyZWQgc3RvcCBzY2FubmluZyBmb3IgemVyb2VzXG4gICAgICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHplcm9lcyBpbiBvY3RldFxuICAgICAgICAgICAgY29uc3QgemVyb3RhYmxlID0ge1xuICAgICAgICAgICAgICAgIDA6IDgsXG4gICAgICAgICAgICAgICAgMTI4OiA3LFxuICAgICAgICAgICAgICAgIDE5MjogNixcbiAgICAgICAgICAgICAgICAyMjQ6IDUsXG4gICAgICAgICAgICAgICAgMjQwOiA0LFxuICAgICAgICAgICAgICAgIDI0ODogMyxcbiAgICAgICAgICAgICAgICAyNTI6IDIsXG4gICAgICAgICAgICAgICAgMjU0OiAxLFxuICAgICAgICAgICAgICAgIDI1NTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBpLCBvY3RldCwgemVyb3M7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDM7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgb2N0ZXQgPSB0aGlzLm9jdGV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob2N0ZXQgaW4gemVyb3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3RhYmxlW29jdGV0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHplcm9zICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNpZHIgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMzIgLSBjaWRyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBjb3JyZXNwb25kcyB0byBvbmUgb2YgdGhlIHNwZWNpYWwgcmFuZ2VzLlxuICAgICAgICBJUHY0LnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpcGFkZHIuc3VibmV0TWF0Y2godGhpcywgdGhpcy5TcGVjaWFsUmFuZ2VzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGJ5dGUtc2l6ZWQgdmFsdWVzIGluIG5ldHdvcmsgb3JkZXIgKE1TQiBmaXJzdClcbiAgICAgICAgSVB2NC5wcm90b3R5cGUudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vY3RldHMuc2xpY2UoMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29udmVydHMgdGhpcyBJUHY0IGFkZHJlc3MgdG8gYW4gSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzLlxuICAgICAgICBJUHY0LnByb3RvdHlwZS50b0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKGA6OmZmZmY6JHt0aGlzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3ltbWV0cmljYWwgbWV0aG9kIHN0cmljdGx5IGZvciBhbGlnbmluZyB3aXRoIHRoZSBJUHY2IG1ldGhvZHMuXG4gICAgICAgIElQdjQucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBpbiBjb252ZW5pZW50LCBkZWNpbWFsLWRvdHRlZCBmb3JtYXQuXG4gICAgICAgIElQdjQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2N0ZXRzLmpvaW4oJy4nKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gSVB2NDtcbiAgICB9KSgpO1xuXG4gICAgLy8gQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJldHVybiBicm9hZGNhc3QgYWRkcmVzcyBnaXZlbiB0aGUgSVB2NCBpbnRlcmZhY2UgYW5kIHByZWZpeCBsZW5ndGggaW4gQ0lEUiBub3RhdGlvblxuICAgIGlwYWRkci5JUHY0LmJyb2FkY2FzdEFkZHJlc3NGcm9tQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2lkciA9IHRoaXMucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCBpcEludGVyZmFjZU9jdGV0cyA9IGNpZHJbMF0udG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym5ldE1hc2tPY3RldHMgPSB0aGlzLnN1Ym5ldE1hc2tGcm9tUHJlZml4TGVuZ3RoKGNpZHJbMV0pLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCBvY3RldHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgNCkge1xuICAgICAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBhZGRyZXNzIGlzIGJpdHdpc2UgT1IgYmV0d2VlbiBpcCBpbnRlcmZhY2UgYW5kIGludmVydGVkIG1hc2tcbiAgICAgICAgICAgICAgICBvY3RldHMucHVzaChwYXJzZUludChpcEludGVyZmFjZU9jdGV0c1tpXSwgMTApIHwgcGFyc2VJbnQoc3VibmV0TWFza09jdGV0c1tpXSwgMTApIF4gMjU1KTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhvY3RldHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBJUHY0IENJRFIgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGZvcm1hdHRlZCBsaWtlIElQdjQgYWRkcmVzcy5cbiAgICBpcGFkZHIuSVB2NC5pc0lQdjQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcihzdHJpbmcpICE9PSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBJUHY0IGFkZHJlc3MuXG4gICAgaXBhZGRyLklQdjQuaXNWYWxpZCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyB0aGlzKHRoaXMucGFyc2VyKHN0cmluZykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBJUHY0IGFkZHJlc3MgaW4gQ0lEUiBub3RhdGlvbi5cbiAgICBpcGFkZHIuSVB2NC5pc1ZhbGlkQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBhIGZ1bGwgZm91ci1wYXJ0IElQdjQgQWRkcmVzcy5cbiAgICBpcGFkZHIuSVB2NC5pc1ZhbGlkRm91clBhcnREZWNpbWFsID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBpZiAoaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpICYmIHN0cmluZy5tYXRjaCgvXigwfFsxLTldXFxkKikoXFwuKDB8WzEtOV1cXGQqKSl7M30kLykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEEgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gbmV0d29yayBhZGRyZXNzIGdpdmVuIHRoZSBJUHY0IGludGVyZmFjZSBhbmQgcHJlZml4IGxlbmd0aCBpbiBDSURSIG5vdGF0aW9uXG4gICAgaXBhZGRyLklQdjQubmV0d29ya0FkZHJlc3NGcm9tQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IGNpZHIsIGksIGlwSW50ZXJmYWNlT2N0ZXRzLCBvY3RldHMsIHN1Ym5ldE1hc2tPY3RldHM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNpZHIgPSB0aGlzLnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgICAgICAgaXBJbnRlcmZhY2VPY3RldHMgPSBjaWRyWzBdLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICBzdWJuZXRNYXNrT2N0ZXRzID0gdGhpcy5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aChjaWRyWzFdKS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgb2N0ZXRzID0gW107XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgNCkge1xuICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgYWRkcmVzcyBpcyBiaXR3aXNlIEFORCBiZXR3ZWVuIGlwIGludGVyZmFjZSBhbmQgbWFza1xuICAgICAgICAgICAgICAgIG9jdGV0cy5wdXNoKHBhcnNlSW50KGlwSW50ZXJmYWNlT2N0ZXRzW2ldLCAxMCkgJiBwYXJzZUludChzdWJuZXRNYXNrT2N0ZXRzW2ldLCAxMCkpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIElQdjQgQ0lEUiBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUcmllcyB0byBwYXJzZSBhbmQgdmFsaWRhdGUgYSBzdHJpbmcgd2l0aCBJUHY0IGFkZHJlc3MuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICAgIGlwYWRkci5JUHY0LnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMucGFyc2VyKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY0IEFkZHJlc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhwYXJ0cyk7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyB0aGUgc3RyaW5nIGFzIGFuIElQdjQgQWRkcmVzcyB3aXRoIENJRFIgTm90YXRpb24uXG4gICAgaXBhZGRyLklQdjQucGFyc2VDSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDMyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gW3RoaXMucGFyc2UobWF0Y2hbMV0pLCBtYXNrTGVuZ3RoXTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyc2VkLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NCBDSURSIHJhbmdlJyk7XG4gICAgfTtcblxuICAgIC8vIENsYXNzZnVsIHZhcmlhbnRzIChsaWtlIGEuYiwgd2hlcmUgYSBpcyBhbiBvY3RldCwgYW5kIGIgaXMgYSAyNC1iaXRcbiAgICAvLyB2YWx1ZSByZXByZXNlbnRpbmcgbGFzdCB0aHJlZSBvY3RldHM7IHRoaXMgY29ycmVzcG9uZHMgdG8gYSBjbGFzcyBDXG4gICAgLy8gYWRkcmVzcykgYXJlIG9taXR0ZWQgZHVlIHRvIGNsYXNzbGVzcyBuYXR1cmUgb2YgbW9kZXJuIEludGVybmV0LlxuICAgIGlwYWRkci5JUHY0LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IG1hdGNoLCBwYXJ0LCB2YWx1ZTtcblxuICAgICAgICAvLyBwYXJzZUludCByZWNvZ25pemVzIGFsbCB0aGF0IG9jdGFsICYgaGV4YWRlY2ltYWwgd2VpcmRuZXNzIGZvciB1c1xuICAgICAgICBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmZvdXJPY3RldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBtYXRjaC5zbGljZSgxLCA2KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcmVmW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnRBdXRvKHBhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLmxvbmdWYWx1ZSkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50QXV0byhtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAweGZmZmZmZmZmIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBzaGlmdDtcblxuICAgICAgICAgICAgICAgIGZvciAoc2hpZnQgPSAwOyBzaGlmdCA8PSAyNDsgc2hpZnQgKz0gOCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goKHZhbHVlID4+IHNoaWZ0KSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKSkucmV2ZXJzZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY0UmVnZXhlcy50d29PY3RldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBtYXRjaC5zbGljZSgxLCA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50QXV0byhyZWZbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDB4ZmZmZmZmIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogYWRkcmVzcyBvdXRzaWRlIGRlZmluZWQgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnRBdXRvKHJlZlswXSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgodmFsdWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCh2YWx1ZSA+PiAgOCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goIHZhbHVlICAgICAgICAmIDB4ZmYpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY0UmVnZXhlcy50aHJlZU9jdGV0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IG1hdGNoLnNsaWNlKDEsIDUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnRBdXRvKHJlZlsyXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHhmZmZmIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogYWRkcmVzcyBvdXRzaWRlIGRlZmluZWQgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnRBdXRvKHJlZlswXSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludEF1dG8ocmVmWzFdKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCh2YWx1ZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggdmFsdWUgICAgICAgJiAweGZmKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEEgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gc3VibmV0IG1hc2sgaW4gSVB2NCBmb3JtYXQgZ2l2ZW4gdGhlIHByZWZpeCBsZW5ndGhcbiAgICBpcGFkZHIuSVB2NC5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcGFyc2VJbnQocHJlZml4KTtcbiAgICAgICAgaWYgKHByZWZpeCA8IDAgfHwgcHJlZml4ID4gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBpbnZhbGlkIElQdjQgcHJlZml4IGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2N0ZXRzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGNvbnN0IGZpbGxlZE9jdGV0Q291bnQgPSBNYXRoLmZsb29yKHByZWZpeCAvIDgpO1xuXG4gICAgICAgIHdoaWxlIChqIDwgZmlsbGVkT2N0ZXRDb3VudCkge1xuICAgICAgICAgICAgb2N0ZXRzW2pdID0gMjU1O1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGxlZE9jdGV0Q291bnQgPCA0KSB7XG4gICAgICAgICAgICBvY3RldHNbZmlsbGVkT2N0ZXRDb3VudF0gPSBNYXRoLnBvdygyLCBwcmVmaXggJSA4KSAtIDEgPDwgOCAtIChwcmVmaXggJSA4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvY3RldHMpO1xuICAgIH07XG5cbiAgICAvLyBBbiBJUHY2IGFkZHJlc3MgKFJGQzI0NjApXG4gICAgaXBhZGRyLklQdjYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDb25zdHJ1Y3RzIGFuIElQdjYgYWRkcmVzcyBmcm9tIGFuIGFycmF5IG9mIGVpZ2h0IDE2IC0gYml0IHBhcnRzXG4gICAgICAgIC8vIG9yIHNpeHRlZW4gOCAtIGJpdCBwYXJ0cyBpbiBuZXR3b3JrIG9yZGVyKE1TQiBmaXJzdCkuXG4gICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZC5cbiAgICAgICAgZnVuY3Rpb24gSVB2NiAocGFydHMsIHpvbmVJZCkge1xuICAgICAgICAgICAgbGV0IGksIHBhcnQ7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gMTQ7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goKHBhcnRzW2ldIDw8IDgpIHwgcGFydHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGlwdjYgcGFydCBjb3VudCBzaG91bGQgYmUgOCBvciAxNicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghKCgwIDw9IHBhcnQgJiYgcGFydCA8PSAweGZmZmYpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaXB2NiBwYXJ0IHNob3VsZCBmaXQgaW4gMTYgYml0cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHpvbmVJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZUlkID0gem9uZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BlY2lhbCBJUHY2IHJhbmdlc1xuICAgICAgICBJUHY2LnByb3RvdHlwZS5TcGVjaWFsUmFuZ2VzID0ge1xuICAgICAgICAgICAgLy8gUkZDNDI5MSwgaGVyZSBhbmQgYWZ0ZXJcbiAgICAgICAgICAgIHVuc3BlY2lmaWVkOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTI4XSxcbiAgICAgICAgICAgIGxpbmtMb2NhbDogW25ldyBJUHY2KFsweGZlODAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMTBdLFxuICAgICAgICAgICAgbXVsdGljYXN0OiBbbmV3IElQdjYoWzB4ZmYwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA4XSxcbiAgICAgICAgICAgIGxvb3BiYWNrOiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDFdKSwgMTI4XSxcbiAgICAgICAgICAgIHVuaXF1ZUxvY2FsOiBbbmV3IElQdjYoWzB4ZmMwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA3XSxcbiAgICAgICAgICAgIGlwdjRNYXBwZWQ6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMHhmZmZmLCAwLCAwXSksIDk2XSxcbiAgICAgICAgICAgIC8vIFJGQzY2NjZcbiAgICAgICAgICAgIGRpc2NhcmQ6IFtuZXcgSVB2NihbMHgxMDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgNjRdLFxuICAgICAgICAgICAgLy8gUkZDNjE0NVxuICAgICAgICAgICAgcmZjNjE0NTogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAweGZmZmYsIDAsIDAsIDBdKSwgOTZdLFxuICAgICAgICAgICAgLy8gUkZDNjA1MlxuICAgICAgICAgICAgcmZjNjA1MjogW25ldyBJUHY2KFsweDY0LCAweGZmOWIsIDAsIDAsIDAsIDAsIDAsIDBdKSwgOTZdLFxuICAgICAgICAgICAgLy8gUkZDMzA1NlxuICAgICAgICAgICAgJzZ0bzQnOiBbbmV3IElQdjYoWzB4MjAwMiwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxNl0sXG4gICAgICAgICAgICAvLyBSRkM2MDUyLCBSRkM2MTQ2XG4gICAgICAgICAgICB0ZXJlZG86IFtuZXcgSVB2NihbMHgyMDAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDMyXSxcbiAgICAgICAgICAgIC8vIFJGQzUxODBcbiAgICAgICAgICAgIGJlbmNobWFya2luZzogW25ldyBJUHY2KFsweDIwMDEsIDB4MiwgMCwgMCwgMCwgMCwgMCwgMF0pLCA0OF0sXG4gICAgICAgICAgICAvLyBSRkM3NDUwXG4gICAgICAgICAgICBhbXQ6IFtuZXcgSVB2NihbMHgyMDAxLCAweDMsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdLFxuICAgICAgICAgICAgYXMxMTJ2NjogW1xuICAgICAgICAgICAgICAgIFtuZXcgSVB2NihbMHgyMDAxLCAweDQsIDB4MTEyLCAwLCAwLCAwLCAwLCAwXSksIDQ4XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjYoWzB4MjYyMCwgMHg0ZiwgMHg4MDAwLCAwLCAwLCAwLCAwLCAwXSksIDQ4XSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkZXByZWNhdGVkOiBbbmV3IElQdjYoWzB4MjAwMSwgMHgxMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAyOF0sXG4gICAgICAgICAgICBvcmNoaWQyOiBbbmV3IElQdjYoWzB4MjAwMSwgMHgyMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAyOF0sXG4gICAgICAgICAgICBkcm9uZVJlbW90ZUlkUHJvdG9jb2xFbnRpdHlUYWdzOiBbbmV3IElQdjYoWzB4MjAwMSwgMHgzMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAyOF0sXG4gICAgICAgICAgICByZXNlcnZlZDogW1xuICAgICAgICAgICAgICAgIC8vIFJGQzM4NDlcbiAgICAgICAgICAgICAgICBbbmV3IElQdjYoWzB4MjAwMSwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAyM10sXG4gICAgICAgICAgICAgICAgLy8gUkZDMjkyOFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NihbMHgyMDAxLCAweGRiOCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGlzIGFkZHJlc3MgaXMgYW4gSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzLlxuICAgICAgICBJUHY2LnByb3RvdHlwZS5pc0lQdjRNYXBwZWRBZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoKSA9PT0gJ2lwdjRNYXBwZWQnO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSAna2luZCcgbWV0aG9kIGV4aXN0cyBvbiBib3RoIElQdjQgYW5kIElQdjYgY2xhc3Nlcy5cbiAgICAgICAgSVB2Ni5wcm90b3R5cGUua2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaXB2Nic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoaXMgYWRkcmVzcyBtYXRjaGVzIG90aGVyIG9uZSB3aXRoaW4gZ2l2ZW4gQ0lEUiByYW5nZS5cbiAgICAgICAgSVB2Ni5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAob3RoZXIsIGNpZHJSYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJlZjtcblxuICAgICAgICAgICAgaWYgKGNpZHJSYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gb3RoZXI7XG4gICAgICAgICAgICAgICAgb3RoZXIgPSByZWZbMF07XG4gICAgICAgICAgICAgICAgY2lkclJhbmdlID0gcmVmWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3RoZXIua2luZCgpICE9PSAnaXB2NicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogY2Fubm90IG1hdGNoIGlwdjYgYWRkcmVzcyB3aXRoIG5vbi1pcHY2IG9uZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hDSURSKHRoaXMucGFydHMsIG90aGVyLnBhcnRzLCAxNiwgY2lkclJhbmdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZXR1cm5zIGEgbnVtYmVyIG9mIGxlYWRpbmcgb25lcyBpbiBJUHY2IGFkZHJlc3MsIG1ha2luZyBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIHJlc3QgaXMgYSBzb2xpZCBzZXF1ZW5jZSBvZiAwJ3MgKHZhbGlkIG5ldG1hc2spXG4gICAgICAgIC8vIHJldHVybnMgZWl0aGVyIHRoZSBDSURSIGxlbmd0aCBvciBudWxsIGlmIG1hc2sgaXMgbm90IHZhbGlkXG4gICAgICAgIElQdjYucHJvdG90eXBlLnByZWZpeExlbmd0aEZyb21TdWJuZXRNYXNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IGNpZHIgPSAwO1xuICAgICAgICAgICAgLy8gbm9uLXplcm8gZW5jb3VudGVyZWQgc3RvcCBzY2FubmluZyBmb3IgemVyb2VzXG4gICAgICAgICAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHplcm9lcyBpbiBvY3RldFxuICAgICAgICAgICAgY29uc3QgemVyb3RhYmxlID0ge1xuICAgICAgICAgICAgICAgIDA6IDE2LFxuICAgICAgICAgICAgICAgIDMyNzY4OiAxNSxcbiAgICAgICAgICAgICAgICA0OTE1MjogMTQsXG4gICAgICAgICAgICAgICAgNTczNDQ6IDEzLFxuICAgICAgICAgICAgICAgIDYxNDQwOiAxMixcbiAgICAgICAgICAgICAgICA2MzQ4ODogMTEsXG4gICAgICAgICAgICAgICAgNjQ1MTI6IDEwLFxuICAgICAgICAgICAgICAgIDY1MDI0OiA5LFxuICAgICAgICAgICAgICAgIDY1MjgwOiA4LFxuICAgICAgICAgICAgICAgIDY1NDA4OiA3LFxuICAgICAgICAgICAgICAgIDY1NDcyOiA2LFxuICAgICAgICAgICAgICAgIDY1NTA0OiA1LFxuICAgICAgICAgICAgICAgIDY1NTIwOiA0LFxuICAgICAgICAgICAgICAgIDY1NTI4OiAzLFxuICAgICAgICAgICAgICAgIDY1NTMyOiAyLFxuICAgICAgICAgICAgICAgIDY1NTM0OiAxLFxuICAgICAgICAgICAgICAgIDY1NTM1OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHBhcnQsIHplcm9zO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCBpbiB6ZXJvdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvdGFibGVbcGFydF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9wICYmIHplcm9zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh6ZXJvcyAhPT0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2lkciArPSB6ZXJvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAxMjggLSBjaWRyO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRzIHRvIG9uZSBvZiB0aGUgc3BlY2lhbCByYW5nZXMuXG4gICAgICAgIElQdjYucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYnl0ZS1zaXplZCB2YWx1ZXMgaW4gbmV0d29yayBvcmRlciAoTVNCIGZpcnN0KVxuICAgICAgICBJUHY2LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxldCBwYXJ0O1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMucGFydHM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcnQgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJ0ID4+IDgpO1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFydCAmIDB4ZmYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBpbiBleHBhbmRlZCBmb3JtYXQgd2l0aCBhbGwgemVyb2VzIGluY2x1ZGVkLCBsaWtlXG4gICAgICAgIC8vIDIwMDE6MGRiODowMDA4OjAwNjY6MDAwMDowMDAwOjAwMDA6MDAwMVxuICAgICAgICBJUHY2LnByb3RvdHlwZS50b0ZpeGVkTGVuZ3RoU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkciA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhZFBhcnQodGhpcy5wYXJ0c1tpXS50b1N0cmluZygxNiksIDQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpLmpvaW4oJzonKTtcblxuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy56b25lSWQpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBgJSR7dGhpcy56b25lSWR9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZHIgKyBzdWZmaXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29udmVydHMgdGhpcyBhZGRyZXNzIHRvIElQdjQgYWRkcmVzcyBpZiBpdCBpcyBhbiBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3MuXG4gICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBvdGhlcndpc2UuXG4gICAgICAgIElQdjYucHJvdG90eXBlLnRvSVB2NEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJUHY0TWFwcGVkQWRkcmVzcygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHRyeWluZyB0byBjb252ZXJ0IGEgZ2VuZXJpYyBpcHY2IGFkZHJlc3MgdG8gaXB2NCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLnBhcnRzLnNsaWNlKC0yKTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSByZWZbMF07XG4gICAgICAgICAgICBjb25zdCBsb3cgPSByZWZbMV07XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoW2hpZ2ggPj4gOCwgaGlnaCAmIDB4ZmYsIGxvdyA+PiA4LCBsb3cgJiAweGZmXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBpbiBleHBhbmRlZCBmb3JtYXQgd2l0aCBhbGwgemVyb2VzIGluY2x1ZGVkLCBsaWtlXG4gICAgICAgIC8vIDIwMDE6ZGI4Ojg6NjY6MDowOjA6MVxuICAgICAgICAvL1xuICAgICAgICAvLyBEZXByZWNhdGVkOiB1c2UgdG9GaXhlZExlbmd0aFN0cmluZygpIGluc3RlYWQuXG4gICAgICAgIElQdjYucHJvdG90eXBlLnRvTm9ybWFsaXplZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHIgPSAoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGFydHNbaV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcykpLmpvaW4oJzonKTtcblxuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy56b25lSWQpIHtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSBgJSR7dGhpcy56b25lSWR9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFkZHIgKyBzdWZmaXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBpbiBjb21wYWN0LCBodW1hbi1yZWFkYWJsZSBmb3JtYXQgbGlrZVxuICAgICAgICAvLyAyMDAxOmRiODo4OjY2OjoxXG4gICAgICAgIC8vIGluIGxpbmUgd2l0aCBSRkMgNTk1MiAoc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1OTUyI3NlY3Rpb24tNClcbiAgICAgICAgSVB2Ni5wcm90b3R5cGUudG9SRkM1OTUyU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSAvKChefDopKDAoOnwkKSl7Mix9KS9nO1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gdGhpcy50b05vcm1hbGl6ZWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2hJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgYmVzdE1hdGNoTGVuZ3RoID0gLTE7XG4gICAgICAgICAgICBsZXQgbWF0Y2g7XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHN0cmluZykpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA+IGJlc3RNYXRjaExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2hJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2hMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoTGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBgJHtzdHJpbmcuc3Vic3RyaW5nKDAsIGJlc3RNYXRjaEluZGV4KX06OiR7c3RyaW5nLnN1YnN0cmluZyhiZXN0TWF0Y2hJbmRleCArIGJlc3RNYXRjaExlbmd0aCl9YDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGNvbXBhY3QsIGh1bWFuLXJlYWRhYmxlIGZvcm1hdCBsaWtlXG4gICAgICAgIC8vIDIwMDE6ZGI4Ojg6NjY6OjFcbiAgICAgICAgLy8gQ2FsbHMgdG9SRkM1OTUyU3RyaW5nIHVuZGVyIHRoZSBob29kLlxuICAgICAgICBJUHY2LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUkZDNTk1MlN0cmluZygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBJUHY2O1xuXG4gICAgfSkoKTtcblxuICAgIC8vIEEgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gYnJvYWRjYXN0IGFkZHJlc3MgZ2l2ZW4gdGhlIElQdjYgaW50ZXJmYWNlIGFuZCBwcmVmaXggbGVuZ3RoIGluIENJRFIgbm90YXRpb25cbiAgICBpcGFkZHIuSVB2Ni5icm9hZGNhc3RBZGRyZXNzRnJvbUNJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaWRyID0gdGhpcy5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGlwSW50ZXJmYWNlT2N0ZXRzID0gY2lkclswXS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgY29uc3Qgc3VibmV0TWFza09jdGV0cyA9IHRoaXMuc3VibmV0TWFza0Zyb21QcmVmaXhMZW5ndGgoY2lkclsxXSkudG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9jdGV0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgIC8vIEJyb2FkY2FzdCBhZGRyZXNzIGlzIGJpdHdpc2UgT1IgYmV0d2VlbiBpcCBpbnRlcmZhY2UgYW5kIGludmVydGVkIG1hc2tcbiAgICAgICAgICAgICAgICBvY3RldHMucHVzaChwYXJzZUludChpcEludGVyZmFjZU9jdGV0c1tpXSwgMTApIHwgcGFyc2VJbnQoc3VibmV0TWFza09jdGV0c1tpXSwgMTApIF4gMjU1KTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhvY3RldHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlwYWRkcjogdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBJUHY2IENJRFIgZm9ybWF0ICgke2V9KWApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBmb3JtYXR0ZWQgbGlrZSBJUHY2IGFkZHJlc3MuXG4gICAgaXBhZGRyLklQdjYuaXNJUHY2ID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIoc3RyaW5nKSAhPT0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIHRvIHNlZSBpZiBzdHJpbmcgaXMgYSB2YWxpZCBJUHY2IEFkZHJlc3NcbiAgICBpcGFkZHIuSVB2Ni5pc1ZhbGlkID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgICAgIC8vIFNpbmNlIElQdjYuaXNWYWxpZCBpcyBhbHdheXMgY2FsbGVkIGZpcnN0LCB0aGlzIHNob3J0Y3V0XG4gICAgICAgIC8vIHByb3ZpZGVzIGEgc3Vic3RhbnRpYWwgcGVyZm9ybWFuY2UgZ2Fpbi5cbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZy5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IHRoaXMucGFyc2VyKHN0cmluZyk7XG4gICAgICAgICAgICBuZXcgdGhpcyhhZGRyLnBhcnRzLCBhZGRyLnpvbmVJZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIElQdjYgYWRkcmVzcyBpbiBDSURSIG5vdGF0aW9uLlxuICAgIGlwYWRkci5JUHY2LmlzVmFsaWRDSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgICAgIC8vIFNlZSBub3RlIGluIElQdjYuaXNWYWxpZFxuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgJiYgc3RyaW5nLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmV0dXJuIG5ldHdvcmsgYWRkcmVzcyBnaXZlbiB0aGUgSVB2NiBpbnRlcmZhY2UgYW5kIHByZWZpeCBsZW5ndGggaW4gQ0lEUiBub3RhdGlvblxuICAgIGlwYWRkci5JUHY2Lm5ldHdvcmtBZGRyZXNzRnJvbUNJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGxldCBjaWRyLCBpLCBpcEludGVyZmFjZU9jdGV0cywgb2N0ZXRzLCBzdWJuZXRNYXNrT2N0ZXRzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaWRyID0gdGhpcy5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgICAgIGlwSW50ZXJmYWNlT2N0ZXRzID0gY2lkclswXS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgc3VibmV0TWFza09jdGV0cyA9IHRoaXMuc3VibmV0TWFza0Zyb21QcmVmaXhMZW5ndGgoY2lkclsxXSkudG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIG9jdGV0cyA9IFtdO1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgLy8gTmV0d29yayBhZGRyZXNzIGlzIGJpdHdpc2UgQU5EIGJldHdlZW4gaXAgaW50ZXJmYWNlIGFuZCBtYXNrXG4gICAgICAgICAgICAgICAgb2N0ZXRzLnB1c2gocGFyc2VJbnQoaXBJbnRlcmZhY2VPY3RldHNbaV0sIDEwKSAmIHBhcnNlSW50KHN1Ym5ldE1hc2tPY3RldHNbaV0sIDEwKSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMob2N0ZXRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpcGFkZHI6IHRoZSBhZGRyZXNzIGRvZXMgbm90IGhhdmUgSVB2NiBDSURSIGZvcm1hdCAoJHtlfSlgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBUcmllcyB0byBwYXJzZSBhbmQgdmFsaWRhdGUgYSBzdHJpbmcgd2l0aCBJUHY2IGFkZHJlc3MuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICAgIGlwYWRkci5JUHY2LnBhcnNlID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcblxuICAgICAgICBpZiAoYWRkci5wYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHN0cmluZyBpcyBub3QgZm9ybWF0dGVkIGxpa2UgYW4gSVB2NiBBZGRyZXNzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYWRkci5wYXJ0cywgYWRkci56b25lSWQpO1xuICAgIH07XG5cbiAgICBpcGFkZHIuSVB2Ni5wYXJzZUNJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGxldCBtYXNrTGVuZ3RoLCBtYXRjaCwgcGFyc2VkO1xuXG4gICAgICAgIGlmICgobWF0Y2ggPSBzdHJpbmcubWF0Y2goL14oLispXFwvKFxcZCspJC8pKSkge1xuICAgICAgICAgICAgbWFza0xlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIGlmIChtYXNrTGVuZ3RoID49IDAgJiYgbWFza0xlbmd0aCA8PSAxMjgpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJzZWQsICd0b1N0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY2IENJRFIgcmFuZ2UnKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgYW4gSVB2NiBhZGRyZXNzLlxuICAgIGlwYWRkci5JUHY2LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IGFkZHIsIGksIG1hdGNoLCBvY3RldCwgb2N0ZXRzLCB6b25lSWQ7XG5cbiAgICAgICAgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY2UmVnZXhlcy5kZXByZWNhdGVkVHJhbnNpdGlvbmFsKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlcihgOjpmZmZmOiR7bWF0Y2hbMV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlwdjZSZWdleGVzLm5hdGl2ZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRJUHY2KHN0cmluZywgOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaChpcHY2UmVnZXhlcy50cmFuc2l0aW9uYWwpKSkge1xuICAgICAgICAgICAgem9uZUlkID0gbWF0Y2hbNl0gfHwgJyc7XG4gICAgICAgICAgICBhZGRyID0gbWF0Y2hbMV1cbiAgICAgICAgICAgIGlmICghbWF0Y2hbMV0uZW5kc1dpdGgoJzo6JykpIHtcbiAgICAgICAgICAgICAgICBhZGRyID0gYWRkci5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHIgPSBleHBhbmRJUHY2KGFkZHIgKyB6b25lSWQsIDYpO1xuICAgICAgICAgICAgaWYgKGFkZHIucGFydHMpIHtcbiAgICAgICAgICAgICAgICBvY3RldHMgPSBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbM10pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChtYXRjaFs0XSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoWzVdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9jdGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvY3RldCA9IG9jdGV0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKDAgPD0gb2N0ZXQgJiYgb2N0ZXQgPD0gMjU1KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkci5wYXJ0cy5wdXNoKG9jdGV0c1swXSA8PCA4IHwgb2N0ZXRzWzFdKTtcbiAgICAgICAgICAgICAgICBhZGRyLnBhcnRzLnB1c2gob2N0ZXRzWzJdIDw8IDggfCBvY3RldHNbM10pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzOiBhZGRyLnBhcnRzLFxuICAgICAgICAgICAgICAgICAgICB6b25lSWQ6IGFkZHIuem9uZUlkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmV0dXJuIHN1Ym5ldCBtYXNrIGluIElQdjYgZm9ybWF0IGdpdmVuIHRoZSBwcmVmaXggbGVuZ3RoXG4gICAgaXBhZGRyLklQdjYuc3VibmV0TWFza0Zyb21QcmVmaXhMZW5ndGggPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHBhcnNlSW50KHByZWZpeCk7XG4gICAgICAgIGlmIChwcmVmaXggPCAwIHx8IHByZWZpeCA+IDEyOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGludmFsaWQgSVB2NiBwcmVmaXggbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvY3RldHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgY29uc3QgZmlsbGVkT2N0ZXRDb3VudCA9IE1hdGguZmxvb3IocHJlZml4IC8gOCk7XG5cbiAgICAgICAgd2hpbGUgKGogPCBmaWxsZWRPY3RldENvdW50KSB7XG4gICAgICAgICAgICBvY3RldHNbal0gPSAyNTU7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbGVkT2N0ZXRDb3VudCA8IDE2KSB7XG4gICAgICAgICAgICBvY3RldHNbZmlsbGVkT2N0ZXRDb3VudF0gPSBNYXRoLnBvdygyLCBwcmVmaXggJSA4KSAtIDEgPDwgOCAtIChwcmVmaXggJSA4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvY3RldHMpO1xuICAgIH07XG5cbiAgICAvLyBUcnkgdG8gcGFyc2UgYW4gYXJyYXkgaW4gbmV0d29yayBvcmRlciAoTVNCIGZpcnN0KSBmb3IgSVB2NCBhbmQgSVB2NlxuICAgIGlwYWRkci5mcm9tQnl0ZUFycmF5ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGlwYWRkci5JUHY0KGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDE2KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGlwYWRkci5JUHY2KGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYmluYXJ5IGlucHV0IGlzIG5laXRoZXIgYW4gSVB2NiBub3IgSVB2NCBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIHZhbGlkIElQIGFkZHJlc3NcbiAgICBpcGFkZHIuaXNWYWxpZCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSB8fCBpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZyk7XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyB2YWxpZCBJUCBhZGRyZXNzIGluIENJRFIgbm90YXRpb25cbiAgICBpcGFkZHIuaXNWYWxpZENJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5pc1ZhbGlkQ0lEUihzdHJpbmcpIHx8IGlwYWRkci5JUHY0LmlzVmFsaWRDSURSKHN0cmluZyk7XG4gICAgfTtcblxuXG4gICAgLy8gQXR0ZW1wdHMgdG8gcGFyc2UgYW4gSVAgQWRkcmVzcywgZmlyc3QgdGhyb3VnaCBJUHY2IHRoZW4gSVB2NC5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICBpcGFkZHIucGFyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGlmIChpcGFkZHIuSVB2Ni5pc1ZhbGlkKHN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY0LnBhcnNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogdGhlIGFkZHJlc3MgaGFzIG5laXRoZXIgSVB2NiBub3IgSVB2NCBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlIENJRFIgbm90YXRpb24sIGZpcnN0IHRocm91Z2ggSVB2NiB0aGVuIElQdjQuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGNvdWxkIG5vdCBiZSBwYXJzZWQuXG4gICAgaXBhZGRyLnBhcnNlQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBpcGFkZHIuSVB2Ni5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IENJRFIgZm9ybWF0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgYW4gYWRkcmVzcyBhbmQgcmV0dXJuIHBsYWluIElQdjQgYWRkcmVzcyBpZiBpdCBpcyBhbiBJUHY0LW1hcHBlZCBhZGRyZXNzXG4gICAgaXBhZGRyLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFkZHIgPSB0aGlzLnBhcnNlKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKGFkZHIua2luZCgpID09PSAnaXB2NicgJiYgYWRkci5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyLnRvSVB2NEFkZHJlc3MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFuIHV0aWxpdHkgZnVuY3Rpb24gdG8gZWFzZSBuYW1lZCByYW5nZSBtYXRjaGluZy4gU2VlIGV4YW1wbGVzIGJlbG93LlxuICAgIC8vIHJhbmdlTGlzdCBjYW4gY29udGFpbiBib3RoIElQdjQgYW5kIElQdjYgc3VibmV0IGVudHJpZXMgYW5kIHdpbGwgbm90IHRocm93IGVycm9yc1xuICAgIC8vIG9uIG1hdGNoaW5nIElQdjQgYWRkcmVzc2VzIHRvIElQdjYgcmFuZ2VzIG9yIHZpY2UgdmVyc2EuXG4gICAgaXBhZGRyLnN1Ym5ldE1hdGNoID0gZnVuY3Rpb24gKGFkZHJlc3MsIHJhbmdlTGlzdCwgZGVmYXVsdE5hbWUpIHtcbiAgICAgICAgbGV0IGksIHJhbmdlTmFtZSwgcmFuZ2VTdWJuZXRzLCBzdWJuZXQ7XG5cbiAgICAgICAgaWYgKGRlZmF1bHROYW1lID09PSB1bmRlZmluZWQgfHwgZGVmYXVsdE5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHROYW1lID0gJ3VuaWNhc3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChyYW5nZU5hbWUgaW4gcmFuZ2VMaXN0KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJhbmdlTGlzdCwgcmFuZ2VOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJhbmdlU3VibmV0cyA9IHJhbmdlTGlzdFtyYW5nZU5hbWVdO1xuICAgICAgICAgICAgICAgIC8vIEVDTUE1IEFycmF5LmlzQXJyYXkgaXNuJ3QgYXZhaWxhYmxlIGV2ZXJ5d2hlcmVcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdWJuZXRzWzBdICYmICEocmFuZ2VTdWJuZXRzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlU3VibmV0cyA9IFtyYW5nZVN1Ym5ldHNdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByYW5nZVN1Ym5ldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VibmV0ID0gcmFuZ2VTdWJuZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5raW5kKCkgPT09IHN1Ym5ldFswXS5raW5kKCkgJiYgYWRkcmVzcy5tYXRjaC5hcHBseShhZGRyZXNzLCBzdWJuZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHROYW1lO1xuICAgIH07XG5cbiAgICAvLyBFeHBvcnQgZm9yIGJvdGggdGhlIENvbW1vbkpTIGFuZCBicm93c2VyLWxpa2UgZW52aXJvbm1lbnRcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBpcGFkZHI7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmlwYWRkciA9IGlwYWRkcjtcbiAgICB9XG5cbn0odGhpcykpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ipaddr.js/lib/ipaddr.js\n");

/***/ })

};
;