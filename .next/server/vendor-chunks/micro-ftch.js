"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micro-ftch";
exports.ids = ["vendor-chunks/micro-ftch"];
exports.modules = {

/***/ "(ssr)/./node_modules/micro-ftch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micro-ftch/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidStatusCodeError = exports.InvalidCertError = void 0;\nconst DEFAULT_OPT = Object.freeze({\n    redirect: true,\n    expectStatusCode: 200,\n    headers: {},\n    full: false,\n    keepAlive: true,\n    cors: false,\n    referrer: false,\n    sslAllowSelfSigned: false,\n    _redirectCount: 0,\n});\nclass InvalidCertError extends Error {\n    constructor(msg, fingerprint256) {\n        super(msg);\n        this.fingerprint256 = fingerprint256;\n    }\n}\nexports.InvalidCertError = InvalidCertError;\nclass InvalidStatusCodeError extends Error {\n    constructor(statusCode) {\n        super(`Request Failed. Status Code: ${statusCode}`);\n        this.statusCode = statusCode;\n    }\n}\nexports.InvalidStatusCodeError = InvalidStatusCodeError;\nfunction detectType(b, type) {\n    if (!type || type === 'text' || type === 'json') {\n        try {\n            let text = new TextDecoder('utf8', { fatal: true }).decode(b);\n            if (type === 'text')\n                return text;\n            try {\n                return JSON.parse(text);\n            }\n            catch (err) {\n                if (type === 'json')\n                    throw err;\n                return text;\n            }\n        }\n        catch (err) {\n            if (type === 'text' || type === 'json')\n                throw err;\n        }\n    }\n    return b;\n}\nlet agents = {};\nfunction fetchNode(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const http = __webpack_require__(/*! http */ \"http\");\n    const https = __webpack_require__(/*! https */ \"https\");\n    const zlib = __webpack_require__(/*! zlib */ \"zlib\");\n    const { promisify } = __webpack_require__(/*! util */ \"util\");\n    const { resolve: urlResolve } = __webpack_require__(/*! url */ \"url\");\n    const isSecure = !!/^https/.test(url);\n    let opts = {\n        method: options.method || 'GET',\n        headers: { 'Accept-Encoding': 'gzip, deflate, br' },\n    };\n    const compactFP = (s) => s.replace(/:| /g, '').toLowerCase();\n    if (options.keepAlive) {\n        const agentOpt = {\n            keepAlive: true,\n            keepAliveMsecs: 30 * 1000,\n            maxFreeSockets: 1024,\n            maxCachedSessions: 1024,\n        };\n        const agentKey = [\n            isSecure,\n            isSecure && options.sslPinnedCertificates?.map((i) => compactFP(i)).sort(),\n        ].join();\n        opts.agent =\n            agents[agentKey] || (agents[agentKey] = new (isSecure ? https : http).Agent(agentOpt));\n    }\n    if (options.type === 'json')\n        opts.headers['Content-Type'] = 'application/json';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    opts.headers = { ...opts.headers, ...options.headers };\n    if (options.sslAllowSelfSigned)\n        opts.rejectUnauthorized = false;\n    const handleRes = async (res) => {\n        const status = res.statusCode;\n        if (options.redirect && 300 <= status && status < 400 && res.headers['location']) {\n            if (options._redirectCount == 10)\n                throw new Error('Request failed. Too much redirects.');\n            options._redirectCount += 1;\n            return await fetchNode(urlResolve(url, res.headers['location']), options);\n        }\n        if (options.expectStatusCode && status !== options.expectStatusCode) {\n            res.resume();\n            throw new InvalidStatusCodeError(status);\n        }\n        let buf = [];\n        for await (const chunk of res)\n            buf.push(chunk);\n        let bytes = Buffer.concat(buf);\n        const encoding = res.headers['content-encoding'];\n        if (encoding === 'br')\n            bytes = await promisify(zlib.brotliDecompress)(bytes);\n        if (encoding === 'gzip' || encoding === 'deflate')\n            bytes = await promisify(zlib.unzip)(bytes);\n        const body = detectType(bytes, options.type);\n        if (options.full)\n            return { headers: res.headers, status, body };\n        return body;\n    };\n    return new Promise((resolve, reject) => {\n        const handleError = async (err) => {\n            if (err && err.code === 'DEPTH_ZERO_SELF_SIGNED_CERT') {\n                try {\n                    await fetchNode(url, { ...options, sslAllowSelfSigned: true, sslPinnedCertificates: [] });\n                }\n                catch (e) {\n                    if (e && e.fingerprint256) {\n                        err = new InvalidCertError(`Self-signed SSL certificate: ${e.fingerprint256}`, e.fingerprint256);\n                    }\n                }\n            }\n            reject(err);\n        };\n        const req = (isSecure ? https : http).request(url, opts, (res) => {\n            res.on('error', handleError);\n            (async () => {\n                try {\n                    resolve(await handleRes(res));\n                }\n                catch (error) {\n                    reject(error);\n                }\n            })();\n        });\n        req.on('error', handleError);\n        const pinned = options.sslPinnedCertificates?.map((i) => compactFP(i));\n        const mfetchSecureConnect = (socket) => {\n            const fp256 = compactFP(socket.getPeerCertificate()?.fingerprint256 || '');\n            if (!fp256 && socket.isSessionReused())\n                return;\n            if (pinned.includes(fp256))\n                return;\n            req.emit('error', new InvalidCertError(`Invalid SSL certificate: ${fp256} Expected: ${pinned}`, fp256));\n            return req.abort();\n        };\n        if (options.sslPinnedCertificates) {\n            req.on('socket', (socket) => {\n                const hasListeners = socket\n                    .listeners('secureConnect')\n                    .map((i) => (i.name || '').replace('bound ', ''))\n                    .includes('mfetchSecureConnect');\n                if (hasListeners)\n                    return;\n                socket.on('secureConnect', mfetchSecureConnect.bind(null, socket));\n            });\n        }\n        if (options.keepAlive)\n            req.setNoDelay(true);\n        if (opts.body)\n            req.write(opts.body);\n        req.end();\n    });\n}\nconst SAFE_HEADERS = new Set(['Accept', 'Accept-Language', 'Content-Language', 'Content-Type'].map((i) => i.toLowerCase()));\nconst FORBIDDEN_HEADERS = new Set(['Accept-Charset', 'Accept-Encoding', 'Access-Control-Request-Headers', 'Access-Control-Request-Method',\n    'Connection', 'Content-Length', 'Cookie', 'Cookie2', 'Date', 'DNT', 'Expect', 'Host', 'Keep-Alive', 'Origin', 'Referer', 'TE', 'Trailer',\n    'Transfer-Encoding', 'Upgrade', 'Via'].map((i) => i.toLowerCase()));\nasync function fetchBrowser(url, _options) {\n    let options = { ...DEFAULT_OPT, ..._options };\n    const headers = new Headers();\n    if (options.type === 'json')\n        headers.set('Content-Type', 'application/json');\n    let parsed = new URL(url);\n    if (parsed.username) {\n        const auth = btoa(`${parsed.username}:${parsed.password}`);\n        headers.set('Authorization', `Basic ${auth}`);\n        parsed.username = '';\n        parsed.password = '';\n    }\n    url = '' + parsed;\n    for (let k in options.headers) {\n        const name = k.toLowerCase();\n        if (SAFE_HEADERS.has(name) || (options.cors && !FORBIDDEN_HEADERS.has(name)))\n            headers.set(k, options.headers[k]);\n    }\n    let opts = { headers, redirect: options.redirect ? 'follow' : 'manual' };\n    if (!options.referrer)\n        opts.referrerPolicy = 'no-referrer';\n    if (options.cors)\n        opts.mode = 'cors';\n    if (options.data) {\n        if (!options.method)\n            opts.method = 'POST';\n        opts.body = options.type === 'json' ? JSON.stringify(options.data) : options.data;\n    }\n    const res = await fetch(url, opts);\n    if (options.expectStatusCode && res.status !== options.expectStatusCode)\n        throw new InvalidStatusCodeError(res.status);\n    const body = detectType(new Uint8Array(await res.arrayBuffer()), options.type);\n    if (options.full)\n        return { headers: Object.fromEntries(res.headers.entries()), status: res.status, body };\n    return body;\n}\nconst IS_NODE = !!(typeof process == 'object' &&\n    process.versions &&\n    process.versions.node &&\n    process.versions.v8);\nfunction fetchUrl(url, options) {\n    const fn = IS_NODE ? fetchNode : fetchBrowser;\n    return fn(url, options);\n}\nexports[\"default\"] = fetchUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWljcm8tZnRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLG9CQUFPO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLFlBQVksWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDeEMsWUFBWSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLGdCQUFLO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3Q0FBd0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUVBQWlFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixpQkFBaUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxPQUFPLFlBQVksT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDaEUsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhcnRpY2xlLWNvbm5lY3RraXQtYXBwLy4vbm9kZV9tb2R1bGVzL21pY3JvLWZ0Y2gvaW5kZXguanM/ODY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFN0YXR1c0NvZGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZENlcnRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IERFRkFVTFRfT1BUID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVkaXJlY3Q6IHRydWUsXG4gICAgZXhwZWN0U3RhdHVzQ29kZTogMjAwLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIGZ1bGw6IGZhbHNlLFxuICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICBjb3JzOiBmYWxzZSxcbiAgICByZWZlcnJlcjogZmFsc2UsXG4gICAgc3NsQWxsb3dTZWxmU2lnbmVkOiBmYWxzZSxcbiAgICBfcmVkaXJlY3RDb3VudDogMCxcbn0pO1xuY2xhc3MgSW52YWxpZENlcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2csIGZpbmdlcnByaW50MjU2KSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuZmluZ2VycHJpbnQyNTYgPSBmaW5nZXJwcmludDI1NjtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDZXJ0RXJyb3IgPSBJbnZhbGlkQ2VydEVycm9yO1xuY2xhc3MgSW52YWxpZFN0YXR1c0NvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlKSB7XG4gICAgICAgIHN1cGVyKGBSZXF1ZXN0IEZhaWxlZC4gU3RhdHVzIENvZGU6ICR7c3RhdHVzQ29kZX1gKTtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRTdGF0dXNDb2RlRXJyb3IgPSBJbnZhbGlkU3RhdHVzQ29kZUVycm9yO1xuZnVuY3Rpb24gZGV0ZWN0VHlwZShiLCB0eXBlKSB7XG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd0ZXh0JyB8fCB0eXBlID09PSAnanNvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogdHJ1ZSB9KS5kZWNvZGUoYik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RleHQnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0JyB8fCB0eXBlID09PSAnanNvbicpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxubGV0IGFnZW50cyA9IHt9O1xuZnVuY3Rpb24gZmV0Y2hOb2RlKHVybCwgX29wdGlvbnMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsgLi4uREVGQVVMVF9PUFQsIC4uLl9vcHRpb25zIH07XG4gICAgY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbiAgICBjb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG4gICAgY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbiAgICBjb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogdXJsUmVzb2x2ZSB9ID0gcmVxdWlyZSgndXJsJyk7XG4gICAgY29uc3QgaXNTZWN1cmUgPSAhIS9eaHR0cHMvLnRlc3QodXJsKTtcbiAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUsIGJyJyB9LFxuICAgIH07XG4gICAgY29uc3QgY29tcGFjdEZQID0gKHMpID0+IHMucmVwbGFjZSgvOnwgL2csICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChvcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb25zdCBhZ2VudE9wdCA9IHtcbiAgICAgICAgICAgIGtlZXBBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBBbGl2ZU1zZWNzOiAzMCAqIDEwMDAsXG4gICAgICAgICAgICBtYXhGcmVlU29ja2V0czogMTAyNCxcbiAgICAgICAgICAgIG1heENhY2hlZFNlc3Npb25zOiAxMDI0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZ2VudEtleSA9IFtcbiAgICAgICAgICAgIGlzU2VjdXJlLFxuICAgICAgICAgICAgaXNTZWN1cmUgJiYgb3B0aW9ucy5zc2xQaW5uZWRDZXJ0aWZpY2F0ZXM/Lm1hcCgoaSkgPT4gY29tcGFjdEZQKGkpKS5zb3J0KCksXG4gICAgICAgIF0uam9pbigpO1xuICAgICAgICBvcHRzLmFnZW50ID1cbiAgICAgICAgICAgIGFnZW50c1thZ2VudEtleV0gfHwgKGFnZW50c1thZ2VudEtleV0gPSBuZXcgKGlzU2VjdXJlID8gaHR0cHMgOiBodHRwKS5BZ2VudChhZ2VudE9wdCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50eXBlID09PSAnanNvbicpXG4gICAgICAgIG9wdHMuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMubWV0aG9kKVxuICAgICAgICAgICAgb3B0cy5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIG9wdHMuYm9keSA9IG9wdGlvbnMudHlwZSA9PT0gJ2pzb24nID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kYXRhKSA6IG9wdGlvbnMuZGF0YTtcbiAgICB9XG4gICAgb3B0cy5oZWFkZXJzID0geyAuLi5vcHRzLmhlYWRlcnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgIGlmIChvcHRpb25zLnNzbEFsbG93U2VsZlNpZ25lZClcbiAgICAgICAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZTtcbiAgICBjb25zdCBoYW5kbGVSZXMgPSBhc3luYyAocmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAob3B0aW9ucy5yZWRpcmVjdCAmJiAzMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8IDQwMCAmJiByZXMuaGVhZGVyc1snbG9jYXRpb24nXSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuX3JlZGlyZWN0Q291bnQgPT0gMTApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGZhaWxlZC4gVG9vIG11Y2ggcmVkaXJlY3RzLicpO1xuICAgICAgICAgICAgb3B0aW9ucy5fcmVkaXJlY3RDb3VudCArPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZldGNoTm9kZSh1cmxSZXNvbHZlKHVybCwgcmVzLmhlYWRlcnNbJ2xvY2F0aW9uJ10pLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlICYmIHN0YXR1cyAhPT0gb3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXR1c0NvZGVFcnJvcihzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWYgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXMpXG4gICAgICAgICAgICBidWYucHVzaChjaHVuayk7XG4gICAgICAgIGxldCBieXRlcyA9IEJ1ZmZlci5jb25jYXQoYnVmKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdicicpXG4gICAgICAgICAgICBieXRlcyA9IGF3YWl0IHByb21pc2lmeSh6bGliLmJyb3RsaURlY29tcHJlc3MpKGJ5dGVzKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnZ3ppcCcgfHwgZW5jb2RpbmcgPT09ICdkZWZsYXRlJylcbiAgICAgICAgICAgIGJ5dGVzID0gYXdhaXQgcHJvbWlzaWZ5KHpsaWIudW56aXApKGJ5dGVzKTtcbiAgICAgICAgY29uc3QgYm9keSA9IGRldGVjdFR5cGUoYnl0ZXMsIG9wdGlvbnMudHlwZSk7XG4gICAgICAgIGlmIChvcHRpb25zLmZ1bGwpXG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiByZXMuaGVhZGVycywgc3RhdHVzLCBib2R5IH07XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnREVQVEhfWkVST19TRUxGX1NJR05FRF9DRVJUJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGZldGNoTm9kZSh1cmwsIHsgLi4ub3B0aW9ucywgc3NsQWxsb3dTZWxmU2lnbmVkOiB0cnVlLCBzc2xQaW5uZWRDZXJ0aWZpY2F0ZXM6IFtdIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSAmJiBlLmZpbmdlcnByaW50MjU2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgSW52YWxpZENlcnRFcnJvcihgU2VsZi1zaWduZWQgU1NMIGNlcnRpZmljYXRlOiAke2UuZmluZ2VycHJpbnQyNTZ9YCwgZS5maW5nZXJwcmludDI1Nik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVxID0gKGlzU2VjdXJlID8gaHR0cHMgOiBodHRwKS5yZXF1ZXN0KHVybCwgb3B0cywgKHJlcykgPT4ge1xuICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhd2FpdCBoYW5kbGVSZXMocmVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICBjb25zdCBwaW5uZWQgPSBvcHRpb25zLnNzbFBpbm5lZENlcnRpZmljYXRlcz8ubWFwKChpKSA9PiBjb21wYWN0RlAoaSkpO1xuICAgICAgICBjb25zdCBtZmV0Y2hTZWN1cmVDb25uZWN0ID0gKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnAyNTYgPSBjb21wYWN0RlAoc29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpPy5maW5nZXJwcmludDI1NiB8fCAnJyk7XG4gICAgICAgICAgICBpZiAoIWZwMjU2ICYmIHNvY2tldC5pc1Nlc3Npb25SZXVzZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocGlubmVkLmluY2x1ZGVzKGZwMjU2KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXEuZW1pdCgnZXJyb3InLCBuZXcgSW52YWxpZENlcnRFcnJvcihgSW52YWxpZCBTU0wgY2VydGlmaWNhdGU6ICR7ZnAyNTZ9IEV4cGVjdGVkOiAke3Bpbm5lZH1gLCBmcDI1NikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcS5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5zc2xQaW5uZWRDZXJ0aWZpY2F0ZXMpIHtcbiAgICAgICAgICAgIHJlcS5vbignc29ja2V0JywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0xpc3RlbmVycyA9IHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAubGlzdGVuZXJzKCdzZWN1cmVDb25uZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoaSkgPT4gKGkubmFtZSB8fCAnJykucmVwbGFjZSgnYm91bmQgJywgJycpKVxuICAgICAgICAgICAgICAgICAgICAuaW5jbHVkZXMoJ21mZXRjaFNlY3VyZUNvbm5lY3QnKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTGlzdGVuZXJzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdzZWN1cmVDb25uZWN0JywgbWZldGNoU2VjdXJlQ29ubmVjdC5iaW5kKG51bGwsIHNvY2tldCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlKVxuICAgICAgICAgICAgcmVxLnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgICAgIGlmIChvcHRzLmJvZHkpXG4gICAgICAgICAgICByZXEud3JpdGUob3B0cy5ib2R5KTtcbiAgICAgICAgcmVxLmVuZCgpO1xuICAgIH0pO1xufVxuY29uc3QgU0FGRV9IRUFERVJTID0gbmV3IFNldChbJ0FjY2VwdCcsICdBY2NlcHQtTGFuZ3VhZ2UnLCAnQ29udGVudC1MYW5ndWFnZScsICdDb250ZW50LVR5cGUnXS5tYXAoKGkpID0+IGkudG9Mb3dlckNhc2UoKSkpO1xuY29uc3QgRk9SQklEREVOX0hFQURFUlMgPSBuZXcgU2V0KFsnQWNjZXB0LUNoYXJzZXQnLCAnQWNjZXB0LUVuY29kaW5nJywgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtSGVhZGVycycsICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZCcsXG4gICAgJ0Nvbm5lY3Rpb24nLCAnQ29udGVudC1MZW5ndGgnLCAnQ29va2llJywgJ0Nvb2tpZTInLCAnRGF0ZScsICdETlQnLCAnRXhwZWN0JywgJ0hvc3QnLCAnS2VlcC1BbGl2ZScsICdPcmlnaW4nLCAnUmVmZXJlcicsICdURScsICdUcmFpbGVyJyxcbiAgICAnVHJhbnNmZXItRW5jb2RpbmcnLCAnVXBncmFkZScsICdWaWEnXS5tYXAoKGkpID0+IGkudG9Mb3dlckNhc2UoKSkpO1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hCcm93c2VyKHVybCwgX29wdGlvbnMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHsgLi4uREVGQVVMVF9PUFQsIC4uLl9vcHRpb25zIH07XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2pzb24nKVxuICAgICAgICBoZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBsZXQgcGFyc2VkID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwYXJzZWQudXNlcm5hbWUpIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IGJ0b2EoYCR7cGFyc2VkLnVzZXJuYW1lfToke3BhcnNlZC5wYXNzd29yZH1gKTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ0F1dGhvcml6YXRpb24nLCBgQmFzaWMgJHthdXRofWApO1xuICAgICAgICBwYXJzZWQudXNlcm5hbWUgPSAnJztcbiAgICAgICAgcGFyc2VkLnBhc3N3b3JkID0gJyc7XG4gICAgfVxuICAgIHVybCA9ICcnICsgcGFyc2VkO1xuICAgIGZvciAobGV0IGsgaW4gb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBrLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChTQUZFX0hFQURFUlMuaGFzKG5hbWUpIHx8IChvcHRpb25zLmNvcnMgJiYgIUZPUkJJRERFTl9IRUFERVJTLmhhcyhuYW1lKSkpXG4gICAgICAgICAgICBoZWFkZXJzLnNldChrLCBvcHRpb25zLmhlYWRlcnNba10pO1xuICAgIH1cbiAgICBsZXQgb3B0cyA9IHsgaGVhZGVycywgcmVkaXJlY3Q6IG9wdGlvbnMucmVkaXJlY3QgPyAnZm9sbG93JyA6ICdtYW51YWwnIH07XG4gICAgaWYgKCFvcHRpb25zLnJlZmVycmVyKVxuICAgICAgICBvcHRzLnJlZmVycmVyUG9saWN5ID0gJ25vLXJlZmVycmVyJztcbiAgICBpZiAob3B0aW9ucy5jb3JzKVxuICAgICAgICBvcHRzLm1vZGUgPSAnY29ycyc7XG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMubWV0aG9kKVxuICAgICAgICAgICAgb3B0cy5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIG9wdHMuYm9keSA9IG9wdGlvbnMudHlwZSA9PT0gJ2pzb24nID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5kYXRhKSA6IG9wdGlvbnMuZGF0YTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCBvcHRzKTtcbiAgICBpZiAob3B0aW9ucy5leHBlY3RTdGF0dXNDb2RlICYmIHJlcy5zdGF0dXMgIT09IG9wdGlvbnMuZXhwZWN0U3RhdHVzQ29kZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0dXNDb2RlRXJyb3IocmVzLnN0YXR1cyk7XG4gICAgY29uc3QgYm9keSA9IGRldGVjdFR5cGUobmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzLmFycmF5QnVmZmVyKCkpLCBvcHRpb25zLnR5cGUpO1xuICAgIGlmIChvcHRpb25zLmZ1bGwpXG4gICAgICAgIHJldHVybiB7IGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXMuaGVhZGVycy5lbnRyaWVzKCkpLCBzdGF0dXM6IHJlcy5zdGF0dXMsIGJvZHkgfTtcbiAgICByZXR1cm4gYm9keTtcbn1cbmNvbnN0IElTX05PREUgPSAhISh0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zLm5vZGUgJiZcbiAgICBwcm9jZXNzLnZlcnNpb25zLnY4KTtcbmZ1bmN0aW9uIGZldGNoVXJsKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZuID0gSVNfTk9ERSA/IGZldGNoTm9kZSA6IGZldGNoQnJvd3NlcjtcbiAgICByZXR1cm4gZm4odXJsLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoVXJsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/micro-ftch/index.js\n");

/***/ })

};
;